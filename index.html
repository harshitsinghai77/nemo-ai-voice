<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lannister Voice Agent</title>

    <!-- âœ… TailwindCSS + Flowbite -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/flowbite@3.1.2/dist/flowbite.min.js"></script>

    <style>
      body {
        background-color: #0f172a; /* slate-900 */
      }
    </style>
  </head>

  <body class="flex flex-col items-center justify-center min-h-screen text-gray-200">
    <div
      class="flex flex-col bg-gray-800 border border-gray-700 rounded-2xl shadow-2xl w-full max-w-3xl h-[80vh] overflow-hidden"
    >
      <!-- Header -->
      <header
        class="flex-shrink-0 p-4 border-b border-gray-700 flex items-center justify-between bg-gray-900"
      >
        <h1 class="text-2xl font-bold text-gray-100">
          Lannister Voice Agent
        </h1>

        <div class="flex items-center space-x-2">
          <div id="status-indicator" class="relative w-3 h-3 rounded-full bg-gray-500"></div>
          <span id="status-text" class="text-sm text-gray-400">Disconnected</span>
        </div>
      </header>

      <!-- Chat messages -->
      <div
        id="chat-box"
        class="flex-1 overflow-y-auto p-6 space-y-4 bg-gray-800"
      >
        <!-- Example intro message -->
        <div class="flex items-start gap-3">
          <div
            class="flex-shrink-0 w-10 h-10 bg-gray-700 text-gray-300 flex items-center justify-center rounded-full"
          >
            ðŸ¤–
          </div>
          <div
            class="px-4 py-3 rounded-2xl max-w-[80%] bg-gray-700 text-gray-200 rounded-bl-lg"
          >
            <p class="text-sm leading-relaxed">
              Hello! I'm your voice planning agent.  
              Connect to start a conversation or paste a document link below.
            </p>
          </div>
        </div>
      </div>

      <!-- Input area -->
      <div class="flex-shrink-0 p-4 border-t border-gray-700">
        <form
          id="chat-form"
          class="flex items-center space-x-3"
          onsubmit="return false;"
        >
          <input
            id="user-input"
            type="text"
            placeholder="Type your message or paste a link..."
            class="flex-1 bg-gray-900 border border-gray-600 rounded-lg px-4 py-2 text-sm text-gray-200 placeholder-gray-500 focus:ring-2 focus:ring-blue-500 focus:outline-none transition duration-200"
          />
          <button
            id="send-btn"
            type="button"
            class="bg-blue-600 text-white px-5 py-2 rounded-lg hover:bg-blue-700 transition duration-200"
          >
            Send
          </button>
        </form>
      </div>

      <!-- Footer -->
      <footer
        class="flex-shrink-0 p-4 border-t border-gray-700 flex items-center justify-center bg-gray-900"
      >
        <button
          id="connect-btn"
          class="px-6 py-2 rounded-lg font-semibold text-white transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 bg-green-600 hover:bg-green-700 focus:ring-green-500"
        >
          Connect Voice
        </button>
        <audio id="audio-el" autoplay class="hidden"></audio>
      </footer>
    </div>

    <script>
      const chatBox = document.getElementById("chat-box");
      const input = document.getElementById("user-input");
      const sendBtn = document.getElementById("send-btn");
      const connectBtn = document.getElementById("connect-btn");
      const statusText = document.getElementById("status-text");
      const statusIndicator = document.getElementById("status-indicator");
      const audioEl = document.getElementById("audio-el");

      let connected = false;
      let peerConnection = null;
      let connectionState = "disconnected"; // disconnected | connecting | connected

      // ---------------- Chat Rendering ----------------
      function appendMessage(isUser, text) {
        const wrapper = document.createElement("div");
        wrapper.className = `flex items-start gap-3 ${
          isUser ? "justify-end" : "justify-start"
        }`;

        if (isUser) {
          wrapper.innerHTML = `
            <div class="px-4 py-3 rounded-2xl max-w-[80%] md:max-w-[70%] bg-blue-600 text-white rounded-br-lg">
              <p class="text-sm leading-relaxed">${text}</p>
            </div>
          `;
        } else {
          wrapper.innerHTML = `
            <div class="flex-shrink-0 w-10 h-10 bg-gray-700 text-gray-300 flex items-center justify-center rounded-full">ðŸ¤–</div>
            <div class="px-4 py-3 rounded-2xl max-w-[80%] md:max-w-[70%] bg-gray-700 text-gray-200 rounded-bl-lg">
              <p class="text-sm leading-relaxed">${text}</p>
            </div>
          `;
        }

        chatBox.appendChild(wrapper);
        chatBox.scrollTop = chatBox.scrollHeight;
      }

      sendBtn.addEventListener("click", () => {
        const message = input.value.trim();
        if (!message) return;
        appendMessage(true, message);

        // Placeholder agent response
        setTimeout(() => {
          appendMessage(false, "Got it! I'll process that link or message and update the plan.");
        }, 800);

        input.value = "";
      });

      // ---------------- WebRTC Logic ----------------
      const sendIceCandidate = async (pc, candidate) => {
        await fetch("/api/offer", {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            pc_id: pc.pc_id,
            candidates: [
              {
                candidate: candidate.candidate,
                sdp_mid: candidate.sdpMid,
                sdp_mline_index: candidate.sdpMLineIndex,
              },
            ],
          }),
        });
      };

      const createSmallWebRTCConnection = async (audioTrack) => {
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });

        pc.pendingIceCandidates = [];
        pc.canSendIceCandidates = false;

        addPeerConnectionEventListeners(pc);
        pc.ontrack = (e) => (audioEl.srcObject = e.streams[0]);
        pc.addTransceiver(audioTrack, { direction: "sendrecv" });
        pc.addTransceiver("video", { direction: "sendrecv" });

        await pc.setLocalDescription(await pc.createOffer());
        const offer = pc.localDescription;
        const response = await fetch("/api/offer", {
          body: JSON.stringify({ sdp: offer.sdp, type: offer.type }),
          headers: { "Content-Type": "application/json" },
          method: "POST",
        });
        const answer = await response.json();
        pc.pc_id = answer.pc_id;
        await pc.setRemoteDescription(answer);

        pc.canSendIceCandidates = true;
        for (const candidate of pc.pendingIceCandidates) {
          await sendIceCandidate(pc, candidate);
        }
        pc.pendingIceCandidates = [];

        return pc;
      };

      const connect = async () => {
        updateConnectionState("connecting");
        const audioStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        peerConnection = await createSmallWebRTCConnection(
          audioStream.getAudioTracks()[0]
        );
      };

      const addPeerConnectionEventListeners = (pc) => {
        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          if (state === "connected") updateConnectionState("connected");
          else if (state === "disconnected") updateConnectionState("disconnected");
        };
        pc.onicecandidate = async (event) => {
          if (event.candidate) {
            if (pc.canSendIceCandidates && pc.pc_id) {
              await sendIceCandidate(pc, event.candidate);
            } else {
              pc.pendingIceCandidates.push(event.candidate);
            }
          }
        };
      };

      const disconnect = () => {
        if (!peerConnection) return;
        peerConnection.close();
        peerConnection = null;
        updateConnectionState("disconnected");
      };

      function updateConnectionState(state) {
        connectionState = state;
        switch (state) {
          case "connecting":
            statusText.textContent = "Connecting...";
            statusIndicator.className =
              "relative w-3 h-3 rounded-full bg-yellow-500 animate-pulse";
            connectBtn.disabled = true;
            connectBtn.textContent = "Connecting...";
            connectBtn.className =
              "px-6 py-2 rounded-lg font-semibold text-white bg-yellow-600 cursor-not-allowed";
            break;

          case "connected":
            statusText.textContent = "Connected";
            statusIndicator.className =
              "relative w-3 h-3 rounded-full bg-green-500";
            connectBtn.disabled = false;
            connectBtn.textContent = "Disconnect";
            connectBtn.className =
              "px-6 py-2 rounded-lg font-semibold text-white bg-red-600 hover:bg-red-700";
            appendMessage(false, "âœ… Connected! Start speaking now.");
            break;

          default:
            statusText.textContent = "Disconnected";
            statusIndicator.className =
              "relative w-3 h-3 rounded-full bg-gray-500";
            connectBtn.disabled = false;
            connectBtn.textContent = "Connect Voice";
            connectBtn.className =
              "px-6 py-2 rounded-lg font-semibold text-white bg-green-600 hover:bg-green-700";
            appendMessage(false, "ðŸ”Œ Disconnected from session.");
            break;
        }
      }

      connectBtn.addEventListener("click", async () => {
        if (connectionState === "connected") disconnect();
        else connect();
      });
    </script>
  </body>
</html>
